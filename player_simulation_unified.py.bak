import argparse
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from bayesian_player_simulator import BayesianPlayerSimulator

class ImprovedBayesianSimulator(BayesianPlayerSimulator):
    """
    Modified version of the BayesianPlayerSimulator that uses better statistical models
    for count data, particularly for rare events like high field goal attempts.
    """
    
    def simulate_game(self, context=None):
        """
        Override the simulate_game method to use improved statistical approaches
        
        Parameters:
        -----------
        context : dict, optional
            Context information - simplified to reduce extreme variations
            
        Returns:
        --------
        dict
            Simulated box score stats
        """
        # Better game type distribution - respect player scoring tendencies
        # For star players like LeBron, hot games should be more frequent
        # Base hot/cold probabilities on player consistency
        player_consistency = self.historical_distributions.get('tendencies', {}).get('consistency', 'average')
        scoring_role = self.historical_distributions.get('tendencies', {}).get('scoring_role', '')
        
        # More variable game type distribution for primary scorers
        if scoring_role in ['primary_option', 'star']:
            hot_prob = 0.20  # Star players have more "hot" games
            cold_prob = 0.10
        elif scoring_role == 'secondary_option':
            hot_prob = 0.15
            cold_prob = 0.15
        else:
            hot_prob = 0.10
            cold_prob = 0.15
        
        # Adjust for player consistency
        if player_consistency == 'high':
            hot_prob *= 0.8
            cold_prob *= 0.8
        elif player_consistency == 'low':
            hot_prob *= 1.2
            cold_prob *= 1.2
            
        avg_prob = 1.0 - (hot_prob + cold_prob)
        self.game_type = np.random.choice(['average', 'hot', 'cold'], 
                                         p=[avg_prob, hot_prob, cold_prob])
        
        # Normal matchup type but consider context if provided
        self.matchup_type = 'normal'
        fixed_context = context or {'home': True}
        
        # Better minutes simulation based on historical data
        minutes = 0
        
        if 'minutes' in self.historical_distributions:
            # Get detailed stats about player's minutes
            minutes_stats = self.historical_distributions['minutes']
            avg_minutes = minutes_stats.get('mean', 30.0)
            min_minutes = minutes_stats.get('min', 20.0)
            max_minutes = minutes_stats.get('max', 40.0)
            std_minutes = minutes_stats.get('std', 5.0)
            
            # Simulate blowout and overtime probabilities
            blowout_prob = 0.15
            overtime_prob = 0.05
            
            # Consider game state for minutes played
            is_blowout = np.random.random() < blowout_prob
            is_overtime = np.random.random() < overtime_prob
            
            if is_blowout:
                # In blowouts, star players often play less
                if scoring_role in ['primary_option', 'star']:
                    minutes = np.random.normal(avg_minutes * 0.85, std_minutes * 0.7)
                else:
                    # Role players might get more minutes in blowouts
                    minutes = np.random.normal(avg_minutes * 1.0, std_minutes * 1.0)
            elif is_overtime:
                # In overtime, primary options play more
                if scoring_role in ['primary_option', 'star']:
                    minutes = np.random.normal(avg_minutes * 1.15, std_minutes * 0.5)
                else:
                    minutes = np.random.normal(avg_minutes * 1.1, std_minutes * 0.6)
            else:
                # Regular game - use full std_minutes for better variance
                minutes = np.random.normal(avg_minutes, std_minutes)
            
            # Ensure minutes are within logical bounds
            minutes = max(min_minutes, min(max_minutes, minutes))
        else:
            # Default minutes with better variance
            minutes = 30.0 + np.random.normal(0, 5.0)
            minutes = max(15.0, min(45.0, minutes))
        
        # Round to reasonable value
        minutes = round(minutes * 10) / 10
        
        # Use our improved box score simulation
        box_score = self._simulate_box_score_improved(minutes)
        box_score['minutes'] = minutes
        
        return box_score
        
    def _simulate_box_score_improved(self, minutes):
        """
        Improved simulation of box score stats - more Bayesian approach
        using better statistical models for count data
        
        Parameters:
        -----------
        minutes : float
            Simulated minutes played
            
        Returns:
        --------
        dict
            Simulated box score statistics
        """
        box_score = {}
        
        # Get player tendencies
        tendencies = self.historical_distributions.get('tendencies', {})
        
        # Determine game type factors (more significant adjustments for hot/cold games)
        # Star players have greater variance in their scoring
        scoring_role = tendencies.get('scoring_role', '')
        
        pts_factor = 1.0
        if self.game_type == 'hot':
            # Star players have more explosive "hot" games
            if scoring_role in ['primary_option', 'star']:
                pts_factor = 1.25  # 25% boost for primary scorers in hot games
            else:
                pts_factor = 1.18  # 18% boost for role players
        elif self.game_type == 'cold':
            if scoring_role in ['primary_option', 'star']:
                pts_factor = 0.80  # Stars have bigger cold games (more variance)
            else:
                pts_factor = 0.85  # Role players more consistent
            
        # When simulating shot attempts, use a true negative binomial distribution
        # This is more appropriate for count data and naturally handles the distribution's tail
        if 'fga' in self.stat_models:
            # Get the posterior samples for FGA per 36 min
            fga_per36_samples = self.stat_models['fga']['posterior_samples']
            
            # Sample from the posterior - this preserves the Bayesian nature
            fga_per36 = np.random.choice(fga_per36_samples)
            
            # Improved non-linear scaling by minutes
            # Players tend to take more shots per minute in higher-minute games
            # This better reflects reality for star players who get into rhythm and dominate
            # when playing extended minutes
            
            # Minutes correction factor to reflect non-linear relationship (usage increases with minutes)
            minutes_correction = 1.0
            if minutes > 36:
                # Higher usage rate in extended minutes for star players
                minutes_correction = 1.0 + 0.05 * (minutes - 36) / 4  # +5% per 4 mins above 36
            elif minutes > 30:
                # Still elevated but less dramatic
                minutes_correction = 1.0 + 0.02 * (minutes - 30) / 6  # +2% per 6 mins above 30
            
            # Apply the non-linear scaling with minutes correction
            fga_lambda = fga_per36 * minutes / 36.0 * minutes_correction
            
            # Account for "hot hand" games better by applying pts_factor directly
            fga_lambda *= pts_factor
                        
            # For FGA, use a better shape parameter that controls the tail weight
            # Less conservative to allow proper variation in scoring
            # Directly estimated from the historical data variance
            r = 8.0  # Less conservative default
            if 'fga' in self.historical_distributions:
                # Use coefficient of variation to determine appropriate shape
                fga_mean = self.historical_distributions['fga']['mean']
                fga_std = self.historical_distributions['fga']['std']
                if fga_mean > 0 and fga_std > 0:
                    cv = fga_std / fga_mean
                    
                    # Check player's role for better shape parameter tuning
                    if scoring_role in ['primary_option', 'star']:
                        # Star players have more variability in shot attempts
                        # Allow heavier tails for occasional high-volume games
                        r = max(3.0, min(15.0, 0.75 / (cv * cv)))
                    else:
                        # Role players are more constrained in shot attempts
                        r = max(4.0, min(20.0, 1.0 / (cv * cv)))
            
            # Convert to probability parameter for negative binomial
            p = r / (r + fga_lambda)
            
            # Generate FGA with proper distributional characteristics
            try:
                # This naturally handles the tail of the distribution
                fga = np.random.negative_binomial(r, p)
            except:
                # Fallback with appropriate game type factor already applied
                fga = np.random.poisson(fga_lambda)
                
            box_score['fga'] = fga
            
            # Now handle 3PA using similar logic but with correlation to FGA
            if 'fg3a' in self.stat_models:
                # Get historical 3-point tendency
                three_pt_rate = tendencies.get('three_pt_rate', 0.3)
                
                # Use a beta distribution to model the proportion of 3PA to FGA
                # Parameters estimated from historical data
                alpha = three_pt_rate * 20
                beta = (1 - three_pt_rate) * 20
                
                # Sample proportion from beta distribution
                prop_3pa = np.random.beta(alpha, beta)
                
                # Apply to FGA, ensuring we don't exceed total FGA
                fg3a = min(fga, round(fga * prop_3pa))
                box_score['fg3a'] = fg3a
                
                # Non-3PA shots are simply the remainder
                non_3pa = fga - fg3a
                
                # Now simulate makes - use binomial for exact counts
                if 'fg_pct' in self.shooting_models:
                    # Get posterior mean for FG%
                    # We need to fall back on a simpler approach since posterior samples
                    # might not be directly accessible in the format we need
                    fg_pct = self.historical_distributions.get('fg_pct', {}).get('mean', 0.45)
                    
                    # Apply game type factor to FG% (hot/cold shooting)
                    # Hot games = better shooting percentage (more efficient)
                    shooting_factor = 1.0
                    if self.game_type == 'hot':
                        shooting_factor = 1.08  # 8% better shooting in hot games
                    elif self.game_type == 'cold':
                        shooting_factor = 0.92  # 8% worse shooting in cold games
                    
                    # Adjusted FG% with game type factor
                    fg_pct_adjusted = min(0.95, fg_pct * shooting_factor)
                    
                    # Add some noise around the adjusted mean - less conservative variance
                    fg_pct_noisy = np.random.normal(fg_pct_adjusted, 0.04)
                    # Ensure reasonable bounds
                    fg_pct_noisy = max(0.2, min(0.95, fg_pct_noisy))
                    
                    # For non-3PT shots
                    if non_3pa > 0:
                        fgm_non3 = np.random.binomial(non_3pa, fg_pct_noisy)
                    else:
                        fgm_non3 = 0
                        
                    if fg3a > 0:
                        # Get 3P% from historical mean
                        fg3_pct = self.historical_distributions.get('fg3_pct', {}).get('mean', 0.35)
                        
                        # Apply game type factor to 3P% (hot/cold shooting)
                        fg3_pct_adjusted = min(0.9, fg3_pct * shooting_factor) 
                        
                        # Add some noise with reasonable variance
                        fg3_pct_noisy = np.random.normal(fg3_pct_adjusted, 0.05)
                        # Ensure reasonable bounds
                        fg3_pct_noisy = max(0.1, min(0.9, fg3_pct_noisy))
                        
                        # Simulate 3PT makes
                        fg3m = np.random.binomial(fg3a, fg3_pct_noisy)
                    else:
                        fg3m = 0
                        
                    # Total FGM is sum of 2PT and 3PT makes
                    fgm = fgm_non3 + fg3m
                    
                    box_score['fgm'] = fgm
                    box_score['fg3m'] = fg3m
        
        # Similar approach for free throws
        if 'fta' in self.stat_models:
            # Get posterior samples for FTA per 36 min
            fta_per36_samples = self.stat_models['fta']['posterior_samples']
            fta_per36 = np.random.choice(fta_per36_samples)
            
            # Apply similar minutes correction factor for FTA
            minutes_correction = 1.0
            if minutes > 36:
                # Higher FT rate in extended minutes (more aggressive driving to basket)
                minutes_correction = 1.0 + 0.06 * (minutes - 36) / 4  # +6% per 4 mins above 36
            elif minutes > 30:
                # Still elevated but less dramatic
                minutes_correction = 1.0 + 0.03 * (minutes - 30) / 6  # +3% per 6 mins above 30
            
            # Scale by minutes, apply game factor and minutes correction
            fta_lambda = fta_per36 * minutes / 36.0 * pts_factor * minutes_correction
            
            # Use better shape parameter based on historical variance and player role
            r_fta = 6.0  # Less conservative default
            if 'fta' in self.historical_distributions:
                fta_mean = self.historical_distributions['fta']['mean']
                fta_std = self.historical_distributions['fta']['std']
                if fta_mean > 0 and fta_std > 0:
                    cv = fta_std / fta_mean
                    
                    # Star players and slashers have higher variance in FTAs
                    if scoring_role in ['primary_option', 'star'] or tendencies.get('playstyle') == 'slasher':
                        r_fta = max(3.0, min(15.0, 0.8 / (cv * cv)))
                    else:
                        r_fta = max(4.0, min(18.0, 1.0 / (cv * cv)))
            
            p_fta = r_fta / (r_fta + fta_lambda)
            
            try:
                fta = np.random.negative_binomial(r_fta, p_fta)
            except:
                fta = np.random.poisson(fta_lambda)
                
            box_score['fta'] = fta
            
            # Simulate makes with improved FT% model
            if fta > 0:
                # Get FT% from historical mean
                ft_pct = self.historical_distributions.get('ft_pct', {}).get('mean', 0.75)
                
                # Apply game type effect on FT%
                ft_game_factor = 1.0
                if self.game_type == 'hot':
                    ft_game_factor = 1.04  # 4% better FT shooting in hot games
                elif self.game_type == 'cold':
                    ft_game_factor = 0.96  # 4% worse FT shooting in cold games
                
                ft_pct_adjusted = min(0.95, ft_pct * ft_game_factor)
                
                # Add appropriate noise based on player consistency
                ft_noise = 0.03
                if tendencies.get('ft_consistency') == 'high':
                    ft_noise = 0.02  # Less variance for consistent FT shooters
                elif tendencies.get('ft_consistency') == 'low':
                    ft_noise = 0.05  # More variance for inconsistent FT shooters
                    
                ft_pct_noisy = np.random.normal(ft_pct_adjusted, ft_noise)
                
                # Ensure percentage is valid with player-appropriate floor
                player_ft_floor = max(0.5, ft_pct - 0.15)  # Player won't shoot worse than 15% below average
                ft_pct_final = max(player_ft_floor, min(0.95, ft_pct_noisy))
                ftm = np.random.binomial(fta, ft_pct_final)
                box_score['ftm'] = ftm
            else:
                box_score['ftm'] = 0
        
        # Simulate other box score stats
        self._simulate_other_stats_improved(box_score, minutes)
        
        # Calculate points
        if all(k in box_score for k in ['fgm', 'fg3m', 'ftm']):
            two_pointers = box_score['fgm'] - box_score['fg3m']
            box_score['pts'] = (two_pointers * 2) + (box_score['fg3m'] * 3) + box_score['ftm']
        
        return box_score
        
    def _simulate_other_stats_improved(self, box_score, minutes):
        """
        Simulate other box score stats using improved Bayesian models
        
        Parameters:
        -----------
        box_score : dict
            Current box score to update
        minutes : float
            Minutes played
        """
        # Improved simulation for rebounds, assists, steals, blocks, turnovers
        # using appropriate negative binomial distributions
        
        for stat in ['reb', 'ast', 'stl', 'blk', 'tov']:
            if stat in self.stat_models:
                # Get posterior samples
                stat_per36_samples = self.stat_models[stat]['posterior_samples']
                stat_per36 = np.random.choice(stat_per36_samples)
                
                # Get player tendencies for proper role-based adjustments
                tendencies = self.historical_distributions.get('tendencies', {})
                scoring_role = tendencies.get('scoring_role', '')
                playstyle = tendencies.get('playstyle', '')
                
                # Apply non-linear minutes scaling for secondary stats too
                minutes_correction = 1.0
                if minutes > 36:
                    minutes_correction = 1.0 + 0.04 * (minutes - 36) / 4  # +4% per 4 mins above 36
                elif minutes > 30:
                    minutes_correction = 1.0 + 0.02 * (minutes - 30) / 6  # +2% per 6 mins above 30
                
                # Apply role-specific stat boosts
                stat_multiplier = 1.0
                
                # Adjust multipliers based on player role and stat type
                if stat == 'reb':
                    if playstyle in ['rebounder', 'big_man']:
                        stat_multiplier = 1.1  # 10% boost for rebounders
                elif stat == 'ast':
                    if playstyle in ['playmaker', 'floor_general']:
                        stat_multiplier = 1.15  # 15% boost for playmakers
                elif stat == 'stl':
                    if playstyle in ['defensive_specialist', 'two_way']:
                        stat_multiplier = 1.12  # 12% boost for defensive players
                elif stat == 'blk':
                    if playstyle in ['rim_protector', 'defensive_specialist']:
                        stat_multiplier = 1.2  # 20% boost for shot blockers
                elif stat == 'tov':
                    # Higher usage = more turnovers  
                    if scoring_role in ['primary_option', 'star']:
                        stat_multiplier = 1.05  # 5% more turnovers for high-usage players
                
                # Apply game type adjustments to secondary stats
                game_type_multiplier = 1.0
                if self.game_type == 'hot':
                    game_type_multiplier = 1.08  # 8% boost in hot games
                elif self.game_type == 'cold':
                    game_type_multiplier = 0.92  # 8% reduction in cold games
                
                # Scale by minutes with appropriate multipliers
                stat_lambda = stat_per36 * minutes / 36.0 * minutes_correction * stat_multiplier * game_type_multiplier
                
                # Better shape parameters based on historical variance and stat type
                r_stat = 5.0  # Default
                if stat in self.historical_distributions:
                    stat_mean = self.historical_distributions[stat]['mean']
                    stat_std = self.historical_distributions[stat]['std']
                    if stat_mean > 0 and stat_std > 0:
                        cv = stat_std / stat_mean
                        
                        # Different stats have different natural variability
                        if stat in ['stl', 'blk']:  # Highly variable
                            # Allow more extreme outliers for defensive stats
                            r_stat = max(1.5, min(8.0, 0.7 / (cv * cv)))
                        elif stat in ['reb', 'ast']: # Moderately variable
                            r_stat = max(2.5, min(12.0, 0.8 / (cv * cv)))
                        else:  # Less variable
                            r_stat = max(3.0, min(15.0, 0.9 / (cv * cv)))
                
                p_stat = r_stat / (r_stat + stat_lambda)
                
                try:
                    stat_value = np.random.negative_binomial(r_stat, p_stat)
                except:
                    # Fallback with appropriate adjustments already applied
                    stat_value = np.random.poisson(stat_lambda)
                    
                box_score[stat] = stat_value
                
                # Handle specific stat details (like offensive/defensive rebounds)
                if stat == 'reb' and stat_value > 0:
                    # Tune O/D reb ratio based on player type
                    if playstyle == 'offensive_rebounder':
                        # More offensive rebounds
                        alpha, beta = 3, 7
                    elif playstyle == 'defensive_rebounder':
                        # More defensive rebounds
                        alpha, beta = 1, 9
                    else:
                        # Default ratio (mostly defensive)
                        alpha, beta = 2, 8
                        
                    oreb_ratio = np.random.beta(alpha, beta)
                    box_score['oreb'] = round(stat_value * oreb_ratio)
                    box_score['dreb'] = stat_value - box_score['oreb']

def create_visualizations(simulator, hist_df, simulated_games, output_dir, player_name):
    """
    Create additional visualizations for the player simulation.
    
    Parameters:
    -----------
    simulator : BayesianPlayerSimulator
        The simulator instance
    hist_df : DataFrame
        Historical player data
    simulated_games : DataFrame
        Simulated game data
    output_dir : str
        Directory for outputs
    player_name : str
        Name of the player
    """
    # Define box score stats to analyze
    box_score_stats = ['pts', 'reb', 'ast', 'stl', 'blk', 'tov', 'fgm', 'fga', 'fg3m', 'fg3a', 'ftm', 'fta']
    
    # Calculate percentiles for historical data
    hist_percentiles = {}
    for stat in box_score_stats + ['minutes']:
        hist_percentiles[stat] = {
            'mean': hist_df[stat].mean(),
            'std': hist_df[stat].std(),
            'min': hist_df[stat].min(),
            'p25': hist_df[stat].quantile(0.25),
            'p50': hist_df[stat].quantile(0.50),
            'p75': hist_df[stat].quantile(0.75),
            'max': hist_df[stat].max()
        }
    
    # Calculate percentiles for simulated data
    sim_percentiles = {}
    for stat in box_score_stats + ['minutes']:
        sim_percentiles[stat] = {
            'mean': simulated_games[stat].mean(),
            'std': simulated_games[stat].std(),
            'min': simulated_games[stat].min(),
            'p25': simulated_games[stat].quantile(0.25),
            'p50': simulated_games[stat].quantile(0.50),
            'p75': simulated_games[stat].quantile(0.75),
            'max': simulated_games[stat].max()
        }
    
    # 1. Create side-by-side box plots for all stats
    fig, axes = plt.subplots(len(box_score_stats), 1, figsize=(12, 4*len(box_score_stats)))
    
    for i, stat in enumerate(box_score_stats):
        ax = axes[i]
        
        # Box plot comparing historical vs simulated
        data = pd.DataFrame({
            'Historical': hist_df[stat],
            'Simulated': simulated_games[stat]
        })
        
        sns.boxplot(data=data, ax=ax, palette=['blue', 'red'])
        
        # Add means as points
        plt.scatter([0, 1], [hist_percentiles[stat]['mean'], sim_percentiles[stat]['mean']], 
                   marker='o', color='yellow', s=100, zorder=3)
        
        # Add statistical details as text
        hist_text = f"μ={hist_percentiles[stat]['mean']:.2f}, σ={hist_percentiles[stat]['std']:.2f}"
        sim_text = f"μ={sim_percentiles[stat]['mean']:.2f}, σ={sim_percentiles[stat]['std']:.2f}"
        
        ax.annotate(hist_text, xy=(0, ax.get_ylim()[1]*0.9), 
                   xytext=(0, ax.get_ylim()[1]*0.9), ha='center')
        ax.annotate(sim_text, xy=(1, ax.get_ylim()[1]*0.9), 
                   xytext=(1, ax.get_ylim()[1]*0.9), ha='center')
        
        ax.set_title(f"{stat.upper()}", fontsize=14)
    
    plt.suptitle(f"{player_name}: Historical vs Bayesian Simulated Stats", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.98])
    plt.savefig(os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_boxplot_comparison.png"))
    plt.close()
    
    # 2. Create correlation plots for key stat relationships
    fig, axes = plt.subplots(2, 2, figsize=(16, 16))
    axes = axes.flatten()
    
    # Determine if player is a three-point specialist
    tendencies = simulator.historical_distributions.get('tendencies', {})
    is_three_specialist = tendencies.get('shooting_profile', '') == 'three_specialist'
    
    # 1. PTS vs FGA
    ax = axes[0]
    ax.scatter(hist_df['fga'], hist_df['pts'], color='blue', alpha=0.4, label='Historical')
    ax.scatter(simulated_games['fga'], simulated_games['pts'], color='red', alpha=0.4, label='Simulated')
    
    hist_corr = np.corrcoef(hist_df['fga'], hist_df['pts'])[0, 1]
    sim_corr = np.corrcoef(simulated_games['fga'], simulated_games['pts'])[0, 1]
    
    ax.set_xlabel('FGA', fontsize=12)
    ax.set_ylabel('PTS', fontsize=12)
    ax.set_title(f'PTS vs FGA (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    ax.legend()
    
    # 2. REB vs Minutes (or 3PA vs PTS for 3PT specialists)
    ax = axes[1]
    if is_three_specialist:
        ax.scatter(hist_df['fg3a'], hist_df['pts'], color='blue', alpha=0.4, label='Historical')
        ax.scatter(simulated_games['fg3a'], simulated_games['pts'], color='red', alpha=0.4, label='Simulated')
        
        hist_corr = np.corrcoef(hist_df['fg3a'], hist_df['pts'])[0, 1]
        sim_corr = np.corrcoef(simulated_games['fg3a'], simulated_games['pts'])[0, 1]
        
        ax.set_xlabel('3PA', fontsize=12)
        ax.set_ylabel('PTS', fontsize=12)
        ax.set_title(f'PTS vs 3PA (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    else:
        ax.scatter(hist_df['minutes'], hist_df['reb'], color='blue', alpha=0.4, label='Historical')
        ax.scatter(simulated_games['minutes'], simulated_games['reb'], color='red', alpha=0.4, label='Simulated')
        
        hist_corr = np.corrcoef(hist_df['minutes'], hist_df['reb'])[0, 1]
        sim_corr = np.corrcoef(simulated_games['minutes'], simulated_games['reb'])[0, 1]
        
        ax.set_xlabel('Minutes', fontsize=12)
        ax.set_ylabel('REB', fontsize=12)
        ax.set_title(f'REB vs Minutes (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    ax.legend()
    
    # 3. AST vs TOV
    ax = axes[2]
    ax.scatter(hist_df['ast'], hist_df['tov'], color='blue', alpha=0.4, label='Historical')
    ax.scatter(simulated_games['ast'], simulated_games['tov'], color='red', alpha=0.4, label='Simulated')
    
    hist_corr = np.corrcoef(hist_df['ast'], hist_df['tov'])[0, 1]
    sim_corr = np.corrcoef(simulated_games['ast'], simulated_games['tov'])[0, 1]
    
    ax.set_xlabel('AST', fontsize=12)
    ax.set_ylabel('TOV', fontsize=12)
    ax.set_title(f'TOV vs AST (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    ax.legend()
    
    # 4. Custom fourth plot based on player style
    ax = axes[3]
    playstyle = tendencies.get('playstyle', 'average')
    
    if playstyle == 'playmaker':
        # For playmakers, show AST vs Minutes
        ax.scatter(hist_df['minutes'], hist_df['ast'], color='blue', alpha=0.4, label='Historical')
        ax.scatter(simulated_games['minutes'], simulated_games['ast'], color='red', alpha=0.4, label='Simulated')
        
        hist_corr = np.corrcoef(hist_df['minutes'], hist_df['ast'])[0, 1]
        sim_corr = np.corrcoef(simulated_games['minutes'], simulated_games['ast'])[0, 1]
        
        ax.set_xlabel('Minutes', fontsize=12)
        ax.set_ylabel('AST', fontsize=12)
        ax.set_title(f'AST vs Minutes (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    elif playstyle == 'rebounder':
        # For rebounders, show OREB vs DREB
        ax.scatter(hist_df['oreb'], hist_df['dreb'], color='blue', alpha=0.4, label='Historical')
        ax.scatter(simulated_games['oreb'], simulated_games['dreb'], color='red', alpha=0.4, label='Simulated')
        
        hist_corr = np.corrcoef(hist_df['oreb'], hist_df['dreb'])[0, 1]
        sim_corr = np.corrcoef(simulated_games['oreb'], simulated_games['dreb'])[0, 1]
        
        ax.set_xlabel('OREB', fontsize=12)
        ax.set_ylabel('DREB', fontsize=12)
        ax.set_title(f'DREB vs OREB (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
    else:
        # Default to FG% vs FT%
        hist_df['fg_pct'] = hist_df['fgm'] / hist_df['fga']
        simulated_games['fg_pct'] = simulated_games['fgm'] / simulated_games['fga']
        hist_df['ft_pct'] = hist_df['ftm'] / hist_df['fta']
        simulated_games['ft_pct'] = simulated_games['ftm'] / simulated_games['fta']
        
        # Replace infinities and NaN
        hist_df.replace([np.inf, -np.inf], np.nan, inplace=True)
        hist_df.dropna(subset=['fg_pct', 'ft_pct'], inplace=True)
        simulated_games.replace([np.inf, -np.inf], np.nan, inplace=True)
        simulated_games.dropna(subset=['fg_pct', 'ft_pct'], inplace=True)
        
        ax.scatter(hist_df['fg_pct'], hist_df['ft_pct'], color='blue', alpha=0.4, label='Historical')
        ax.scatter(simulated_games['fg_pct'], simulated_games['ft_pct'], color='red', alpha=0.4, label='Simulated')
        
        try:
            hist_corr = np.corrcoef(hist_df['fg_pct'], hist_df['ft_pct'])[0, 1]
            sim_corr = np.corrcoef(simulated_games['fg_pct'], simulated_games['ft_pct'])[0, 1]
            
            ax.set_xlabel('FG%', fontsize=12)
            ax.set_ylabel('FT%', fontsize=12)
            ax.set_title(f'FT% vs FG% (Corr: Hist={hist_corr:.2f}, Sim={sim_corr:.2f})', fontsize=14)
        except:
            ax.set_xlabel('FG%', fontsize=12)
            ax.set_ylabel('FT%', fontsize=12)
            ax.set_title(f'FT% vs FG%', fontsize=14)
    
    ax.legend()
    
    plt.suptitle(f"{player_name}: Statistical Relationships in Bayesian Simulation", fontsize=16)
    plt.tight_layout(rect=[0, 0, 1, 0.98])
    plt.savefig(os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_stat_relationships.png"))
    plt.close()
    
    # 3. Create special visualizations for 3-point specialists
    if is_three_specialist:
        plt.figure(figsize=(10, 6))
        bins = np.arange(0, 15, 1)
        
        plt.hist(hist_df['fg3m'], bins=bins, alpha=0.5, label='Historical', color='blue')
        plt.hist(simulated_games['fg3m'], bins=bins, alpha=0.5, label='Simulated', color='red')
        
        plt.axvline(hist_df['fg3m'].mean(), color='blue', linestyle='dashed', linewidth=2, 
                    label=f'Historical Mean: {hist_df["fg3m"].mean():.2f}')
        plt.axvline(simulated_games['fg3m'].mean(), color='red', linestyle='dashed', linewidth=2,
                    label=f'Simulated Mean: {simulated_games["fg3m"].mean():.2f}')
        
        plt.title(f"{player_name}: 3-Point Makes Distribution", fontsize=14)
        plt.xlabel("3PM", fontsize=12)
        plt.ylabel("Frequency", fontsize=12)
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.savefig(os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_3pm_distribution.png"))
        plt.close()
    
    # 4. Create game type analysis
    if 'game_type' in simulated_games.columns:
        # Group key stats by game type
        game_type_stats = simulated_games.groupby('game_type')[box_score_stats].mean().reset_index()
        
        # Create a sorted bar chart for key stats
        key_stats = ['pts', 'reb', 'ast', 'fg3m'] if is_three_specialist else ['pts', 'reb', 'ast']
        
        for stat in key_stats:
            plt.figure(figsize=(10, 6))
            ordered_data = game_type_stats.sort_values(stat, ascending=False)
            
            bars = plt.bar(ordered_data['game_type'], ordered_data[stat])
            
            # Add historical mean reference line
            hist_mean = hist_percentiles[stat]['mean']
            plt.axhline(y=hist_mean, linestyle='--', color='black', 
                       label=f'Historical Mean: {hist_mean:.2f}')
            
            # Add value labels on bars
            for bar in bars:
                height = bar.get_height()
                plt.text(bar.get_x() + bar.get_width()/2., height,
                       f'{height:.2f}', ha='center', va='bottom')
            
            plt.title(f'{player_name}: Average {stat.upper()} by Game Type', fontsize=14)
            plt.ylabel(stat.upper())
            plt.xlabel('Game Type')
            plt.legend()
            plt.tight_layout()
            plt.savefig(os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_{stat}_by_game_type.png"))
            plt.close()
    
    # 5. Save all percentile data
    combined_percentiles = {
        'Historical': hist_percentiles,
        'Simulated': sim_percentiles
    }
    
    # Convert to a more pandas-friendly format
    percentile_rows = []
    for stat in box_score_stats + ['minutes']:
        row = {'Stat': stat}
        row.update({f'hist_{metric}': hist_percentiles[stat][metric] for metric in hist_percentiles[stat]})
        row.update({f'sim_{metric}': sim_percentiles[stat][metric] for metric in sim_percentiles[stat]})
        percentile_rows.append(row)
    
    percentile_df = pd.DataFrame(percentile_rows)
    percentile_df.to_csv(os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_percentiles.csv"), index=False)

def print_summary(simulator, hist_df, simulated_games, summary_stats):
    """
    Print a summary of the simulation results.
    
    Parameters:
    -----------
    simulator : BayesianPlayerSimulator
        The simulator instance
    hist_df : DataFrame
        Historical player data
    simulated_games : DataFrame
        Simulated game data
    summary_stats : DataFrame
        Summary statistics comparison
    """
    box_score_stats = ['pts', 'reb', 'ast', 'stl', 'blk', 'tov', 'fgm', 'fga', 'fg3m', 'fg3a', 'ftm', 'fta']
    
    # Calculate percentiles for historical data
    hist_percentiles = {}
    for stat in box_score_stats + ['minutes']:
        hist_percentiles[stat] = {
            'mean': hist_df[stat].mean(),
            'std': hist_df[stat].std(),
        }
    
    # Calculate percentiles for simulated data
    sim_percentiles = {}
    for stat in box_score_stats + ['minutes']:
        sim_percentiles[stat] = {
            'mean': simulated_games[stat].mean(),
            'std': simulated_games[stat].std(),
        }
    
    print("\nBayesian simulation complete!")
    print("\nKey findings:")
    for stat in box_score_stats:
        hist_mean = hist_percentiles[stat]['mean']
        sim_mean = sim_percentiles[stat]['mean']
        pct_diff = ((sim_mean - hist_mean) / hist_mean) * 100
        
        hist_std = hist_percentiles[stat]['std']
        sim_std = sim_percentiles[stat]['std']
        std_pct_diff = ((sim_std - hist_std) / hist_std) * 100
        
        print(f"{stat.upper()}: Hist mean={hist_mean:.2f}, Sim mean={sim_mean:.2f} ({pct_diff:+.1f}%) | " 
              f"Hist std={hist_std:.2f}, Sim std={sim_std:.2f} ({std_pct_diff:+.1f}%)")
    
    # Print tendencies
    print("\nPlayer Tendencies detected:")
    for key, value in simulator.historical_distributions.get('tendencies', {}).items():
        if isinstance(value, (str, int, float)):
            print(f"- {key}: {value}")
    
    # For 3-point specialists, print additional 3-point metrics
    tendencies = simulator.historical_distributions.get('tendencies', {})
    is_three_specialist = tendencies.get('shooting_profile', '') == 'three_specialist'
    
    if is_three_specialist:
        hist_3pt_rate = hist_df['fg3a'].sum() / hist_df['fga'].sum()
        sim_3pt_rate = simulated_games['fg3a'].sum() / simulated_games['fga'].sum()
        
        hist_3pt_pct = hist_df['fg3m'].sum() / hist_df['fg3a'].sum()
        sim_3pt_pct = simulated_games['fg3m'].sum() / simulated_games['fg3a'].sum()
        
        print(f"\n3-Point Metrics:")
        print(f"- 3PA Rate: Historical {hist_3pt_rate:.3f} vs Simulated {sim_3pt_rate:.3f} ({(sim_3pt_rate-hist_3pt_rate)/hist_3pt_rate*100:+.1f}%)")
        print(f"- 3PT%: Historical {hist_3pt_pct:.3f} vs Simulated {sim_3pt_pct:.3f} ({(sim_3pt_pct-hist_3pt_pct)/hist_3pt_pct*100:+.1f}%)")
        print(f"- 3PM per game: Historical {hist_df['fg3m'].mean():.2f} vs Simulated {simulated_games['fg3m'].mean():.2f} ({(simulated_games['fg3m'].mean()-hist_df['fg3m'].mean())/hist_df['fg3m'].mean()*100:+.1f}%)")

def create_cross_player_analysis(results, output_dir):
    """
    Create comparative analysis across multiple players.
    
    Parameters:
    -----------
    results : dict
        Dictionary mapping player names to their simulation results
    output_dir : str
        Base directory for outputs
    """
    # Extract key metrics from each player's simulation
    player_metrics = []
    
    for player_name, data in results.items():
        simulator = data['simulator']
        hist_df = data['historical_data']
        sim_df = data['simulated_games']
        
        # Extract tendencies
        tendencies = simulator.historical_distributions.get('tendencies', {})
        
        # Calculate basic metrics
        hist_pts_mean = hist_df['pts'].mean()
        sim_pts_mean = sim_df['pts'].mean()
        pts_diff_pct = ((sim_pts_mean - hist_pts_mean) / hist_pts_mean) * 100
        
        # Calculate shooting percentages
        hist_fg_pct = hist_df['fgm'].sum() / hist_df['fga'].sum()
        sim_fg_pct = sim_df['fgm'].sum() / sim_df['fga'].sum()
        
        hist_3pt_pct = hist_df['fg3m'].sum() / hist_df['fg3a'].sum() if hist_df['fg3a'].sum() > 0 else 0
        sim_3pt_pct = sim_df['fg3m'].sum() / sim_df['fg3a'].sum() if sim_df['fg3a'].sum() > 0 else 0
        
        hist_ft_pct = hist_df['ftm'].sum() / hist_df['fta'].sum() if hist_df['fta'].sum() > 0 else 0
        sim_ft_pct = sim_df['ftm'].sum() / sim_df['fta'].sum() if sim_df['fta'].sum() > 0 else 0
        
        # Collect metrics
        metrics = {
            'player_name': player_name,
            'scoring_role': tendencies.get('scoring_role', ''),
            'playstyle': tendencies.get('playstyle', ''),
            'shooting_profile': tendencies.get('shooting_profile', ''),
            'hist_pts_mean': hist_pts_mean,
            'sim_pts_mean': sim_pts_mean,
            'pts_diff_pct': pts_diff_pct,
            'hist_fg_pct': hist_fg_pct,
            'sim_fg_pct': sim_fg_pct,
            'hist_3pt_pct': hist_3pt_pct,
            'sim_3pt_pct': sim_3pt_pct,
            'hist_ft_pct': hist_ft_pct,
            'sim_ft_pct': sim_ft_pct,
            'hist_reb_mean': hist_df['reb'].mean(),
            'sim_reb_mean': sim_df['reb'].mean(),
            'hist_ast_mean': hist_df['ast'].mean(),
            'sim_ast_mean': sim_df['ast'].mean(),
            'hist_stl_mean': hist_df['stl'].mean(),
            'sim_stl_mean': sim_df['stl'].mean(),
            'hist_blk_mean': hist_df['blk'].mean(),
            'sim_blk_mean': sim_df['blk'].mean(),
            'hist_tov_mean': hist_df['tov'].mean(),
            'sim_tov_mean': sim_df['tov'].mean(),
        }
        
        player_metrics.append(metrics)
    
    # Create a DataFrame with all player metrics
    if player_metrics:
        metrics_df = pd.DataFrame(player_metrics)
        metrics_df.to_csv(os.path.join(output_dir, "player_simulation_comparison.csv"), index=False)
        
        # Create visualizations comparing players
        create_cross_player_visualizations(metrics_df, output_dir)

def create_cross_player_visualizations(metrics_df, output_dir):
    """
    Create visualizations comparing different players.
    
    Parameters:
    -----------
    metrics_df : DataFrame
        DataFrame with metrics for each player
    output_dir : str
        Base directory for outputs
    """
    # 1. Points prediction accuracy
    plt.figure(figsize=(12, 8))
    
    # Sort by historical points
    sorted_df = metrics_df.sort_values('hist_pts_mean', ascending=False).head(15)  # Top 15 players
    
    x = np.arange(len(sorted_df))
    width = 0.35
    
    # Plot historical and simulated points side by side
    plt.bar(x - width/2, sorted_df['hist_pts_mean'], width, label='Historical', color='blue', alpha=0.7)
    plt.bar(x + width/2, sorted_df['sim_pts_mean'], width, label='Simulated', color='red', alpha=0.7)
    
    # Add percent difference as text
    for i, row in enumerate(sorted_df.itertuples()):
        plt.text(i, max(row.hist_pts_mean, row.sim_pts_mean) + 1, 
                f"{row.pts_diff_pct:+.1f}%", ha='center', rotation=45)
    
    plt.xlabel('Player')
    plt.ylabel('Points per Game')
    plt.title('Comparison of Historical vs Simulated Points per Game')
    plt.xticks(x, sorted_df['player_name'], rotation=45, ha='right')
    plt.legend()
    plt.grid(axis='y', alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, "points_comparison.png"))
    plt.close()
    
    # 2. Shooting percentage accuracy
    plt.figure(figsize=(15, 10))
    
    # Create subplot for each shooting percentage
    fig, axes = plt.subplots(3, 1, figsize=(12, 18))
    
    # Field Goal %
    sorted_fg = metrics_df.sort_values('hist_fg_pct', ascending=False).head(15)
    axes[0].bar(np.arange(len(sorted_fg)) - width/2, sorted_fg['hist_fg_pct'], width, label='Historical', color='blue', alpha=0.7)
    axes[0].bar(np.arange(len(sorted_fg)) + width/2, sorted_fg['sim_fg_pct'], width, label='Simulated', color='red', alpha=0.7)
    axes[0].set_xlabel('Player')
    axes[0].set_ylabel('FG%')
    axes[0].set_title('Field Goal Percentage Comparison')
    axes[0].set_xticks(np.arange(len(sorted_fg)))
    axes[0].set_xticklabels(sorted_fg['player_name'], rotation=45, ha='right')
    axes[0].legend()
    axes[0].grid(axis='y', alpha=0.3)
    
    # 3-Point %
    sorted_3pt = metrics_df.sort_values('hist_3pt_pct', ascending=False).head(15)
    axes[1].bar(np.arange(len(sorted_3pt)) - width/2, sorted_3pt['hist_3pt_pct'], width, label='Historical', color='blue', alpha=0.7)
    axes[1].bar(np.arange(len(sorted_3pt)) + width/2, sorted_3pt['sim_3pt_pct'], width, label='Simulated', color='red', alpha=0.7)
    axes[1].set_xlabel('Player')
    axes[1].set_ylabel('3P%')
    axes[1].set_title('3-Point Percentage Comparison')
    axes[1].set_xticks(np.arange(len(sorted_3pt)))
    axes[1].set_xticklabels(sorted_3pt['player_name'], rotation=45, ha='right')
    axes[1].legend()
    axes[1].grid(axis='y', alpha=0.3)
    
    # Free Throw %
    sorted_ft = metrics_df.sort_values('hist_ft_pct', ascending=False).head(15)
    axes[2].bar(np.arange(len(sorted_ft)) - width/2, sorted_ft['hist_ft_pct'], width, label='Historical', color='blue', alpha=0.7)
    axes[2].bar(np.arange(len(sorted_ft)) + width/2, sorted_ft['sim_ft_pct'], width, label='Simulated', color='red', alpha=0.7)
    axes[2].set_xlabel('Player')
    axes[2].set_ylabel('FT%')
    axes[2].set_title('Free Throw Percentage Comparison')
    axes[2].set_xticks(np.arange(len(sorted_ft)))
    axes[2].set_xticklabels(sorted_ft['player_name'], rotation=45, ha='right')
    axes[2].legend()
    axes[2].grid(axis='y', alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, "shooting_pct_comparison.png"))
    plt.close()
    
    # 3. Grouped by player type/role
    if 'playstyle' in metrics_df.columns:
        # Calculate average points by playstyle
        playstyle_pts = metrics_df.groupby('playstyle')[['hist_pts_mean', 'sim_pts_mean']].mean().reset_index()
        
        plt.figure(figsize=(10, 6))
        x = np.arange(len(playstyle_pts))
        
        plt.bar(x - width/2, playstyle_pts['hist_pts_mean'], width, label='Historical', color='blue', alpha=0.7)
        plt.bar(x + width/2, playstyle_pts['sim_pts_mean'], width, label='Simulated', color='red', alpha=0.7)
        
        plt.xlabel('Player Playstyle')
        plt.ylabel('Average Points per Game')
        plt.title('Points per Game by Playstyle')
        plt.xticks(x, playstyle_pts['playstyle'])
        plt.legend()
        plt.grid(axis='y', alpha=0.3)
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, "points_by_playstyle.png"))
        plt.close()

def run_player_simulation(player_name, num_games=100, output_dir=None, verbose=True, slim=False):
    """
    Run a Bayesian simulation for a specific player.
    
    Parameters:
    -----------
    player_name : str
        Name of the player to simulate
    num_games : int, default=100
        Number of games to simulate
    output_dir : str, optional
        Base directory for outputs. If None, will use timestamped folder or player name
    verbose : bool, default=True
        Whether to print progress information
    slim : bool, default=False
        If True, only generates simulation data without visualizations
    
    Returns:
    --------
    tuple or DataFrame
        If slim=False: (simulator, simulated_games, historical_data, summary_stats)
        If slim=True: simulated_games DataFrame only
    """
    # Set up output directory based on mode
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    if output_dir is None:
        if slim:
            output_dir = f"run_{timestamp}"
        else:
            output_dir = f"{player_name.replace(' ', '_').lower()}_sim_results"
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Initialize simulator using our improved Bayesian model
    if verbose:
        print(f"Initializing Bayesian simulator for {player_name}...")
    
    simulator = ImprovedBayesianSimulator(player_id=player_name, verbose=verbose)
    
    # Simulate games
    if verbose:
        print(f"Simulating {num_games} games for {player_name}...")
    
    simulated_games = simulator.simulate_games(
        n_games=num_games, 
        output_file=os.path.join(output_dir, f"{player_name.replace(' ', '_').lower()}_games.csv")
    )
    
    # Add player name column for easy identification in batch mode
    simulated_games['player_name'] = player_name
    
    # If in slim mode, just return the simulated games
    if slim:
        if verbose:
            print(f"Simulation complete. Results saved to {output_dir}")
        return simulated_games
    
    # Otherwise continue with comparisons and visualizations
    if verbose:
        print("\nComparing simulated games with historical data...")
    
    hist_df, summary_stats = simulator.compare_with_historical(
        simulated_games, 
        output_dir=output_dir
    )
    
    # Create additional visualizations
    if verbose:
        print("\nGenerating additional visualizations...")
    
    create_visualizations(simulator, hist_df, simulated_games, output_dir, player_name)
    
    # Print summary statistics
    if verbose:
        print_summary(simulator, hist_df, simulated_games, summary_stats)
    
    return simulator, simulated_games, hist_df, summary_stats

def batch_simulate_players(player_list, num_games=100, output_dir=None, verbose=True, slim=False):
    """
    Run batch simulations for multiple players.
    
    Parameters:
    -----------
    player_list : list
        List of player names to simulate
    num_games : int, default=100
        Number of games to simulate for each player
    output_dir : str, optional
        Base directory for outputs
    verbose : bool, default=True
        Whether to print progress information
    slim : bool, default=False
        If True, only generates simulation data without visualizations
    
    Returns:
    --------
    dict or DataFrame
        If slim=False: Dictionary mapping player names to their simulation results
        If slim=True: Combined DataFrame with all players' simulated games
    """
    # Set up output directory based on mode
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    if output_dir is None:
        if slim:
            output_dir = f"run_{timestamp}"
        else:
            output_dir = "player_simulations"
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    results = {}
    all_simulated_games = []
    
    for i, player_name in enumerate(player_list):
        if verbose:
            print(f"\n[{i+1}/{len(player_list)}] Processing {player_name}...")
        
        try:
            if slim:
                player_dir = output_dir  # All in same directory for slim mode
                simulated_games = run_player_simulation(
                    player_name, 
                    num_games=num_games, 
                    output_dir=player_dir,
                    verbose=verbose,
                    slim=True
                )
                all_simulated_games.append(simulated_games)
            else:
                player_dir = os.path.join(output_dir, player_name.replace(' ', '_').lower())
                simulator, simulated_games, hist_df, summary_stats = run_player_simulation(
                    player_name, 
                    num_games=num_games, 
                    output_dir=player_dir,
                    verbose=verbose,
                    slim=False
                )
                
                results[player_name] = {
                    'simulator': simulator,
                    'simulated_games': simulated_games,
                    'historical_data': hist_df,
                    'summary_stats': summary_stats
                }
            
            if verbose:
                print(f"Successfully simulated {player_name}")
        except Exception as e:
            if verbose:
                print(f"Error simulating {player_name}: {str(e)}")
    
    if slim:
        # Combine all simulations into a single DataFrame for slim mode
        if all_simulated_games:
            combined_df = pd.concat(all_simulated_games, ignore_index=True)
            combined_output_file = os.path.join(output_dir, "all_player_simulations.csv")
            combined_df.to_csv(combined_output_file, index=False)
            
            if verbose:
                print(f"\nCombined simulations saved to {combined_output_file}")
            
            return combined_df
        else:
            if verbose:
                print("\nNo successful simulations to combine.")
            return None
    else:
        # Create comparative analysis across players for full mode
        if verbose and len(results) > 1:
            print("\nCreating cross-player analysis...")
        
        if len(results) > 1:
            create_cross_player_analysis(results, output_dir)
        
        return results

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run Bayesian player simulations')
    parser.add_argument('--player', '-p', type=str, help='Player name to simulate (use comma for multiple players)')
    parser.add_argument('--games', '-g', type=int, default=100, help='Number of games to simulate')
    parser.add_argument('--output', '-o', type=str, help='Output directory')
    parser.add_argument('--quiet', '-q', action='store_true', help='Run in quiet mode')
    parser.add_argument('--slim', '-s', action='store_true', help='Run in slim mode (only generate data, no visualizations)')
    
    args = parser.parse_args()
    
    if args.player:
        # Single player or comma-separated list
        players = [name.strip() for name in args.player.split(',')]
        
        if len(players) == 1:
            # Single player mode
            run_player_simulation(
                players[0],
                num_games=args.games,
                output_dir=args.output,
                verbose=not args.quiet,
                slim=args.slim
            )
        else:
            # Batch mode for specified players
            batch_simulate_players(
                players,
                num_games=args.games,
                output_dir=args.output,
                verbose=not args.quiet,
                slim=args.slim
            )
    else:
        # Example players if none specified
        example_players = ["LeBron James", "Stephen Curry", "Kevin Durant"]
        print(f"No player specified. Running example simulation with: {', '.join(example_players)}")
        
        batch_simulate_players(
            example_players,
            num_games=args.games,
            output_dir=args.output,
            verbose=not args.quiet,
            slim=args.slim
        )